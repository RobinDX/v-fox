wineps.drv : send page size when printing

From: Massimo Del Fedele <max@veneto.com>


---
 dlls/wineps.drv/escape.c |   44 ++++++++++++++++++++++++++++++++++++++++++--
 1 files changed, 42 insertions(+), 2 deletions(-)

diff --git a/dlls/wineps.drv/escape.c b/dlls/wineps.drv/escape.c
index 1062b96..bb648d3 100644
--- a/dlls/wineps.drv/escape.c
+++ b/dlls/wineps.drv/escape.c
@@ -47,10 +47,11 @@ static const char psbegindocument[] =
 "%%BeginDocument: Wine passthrough\n";
 
 /* FIXME: should use winspool functions instead */
-static DWORD create_job(LPCSTR pszOutput)
+static DWORD create_job(LPCSTR pszOutput, LPCSTR pszPageSize)
 {
     int fd = -1;
     char psCmd[1024];
+    char psCmd2[1024];
     const char *psCmdP = psCmd;
     HKEY hkey;
 
@@ -81,6 +82,15 @@ static DWORD create_job(LPCSTR pszOutput)
         }
         if (!*psCmdP) return 0;
     }
+    
+    /* copy printer command in order to add page size */
+    strcpy(psCmd2, psCmdP);
+    psCmdP = psCmd2;
+    
+    /* if page size given, append it to printer line */
+    if(pszPageSize)
+		strcat(psCmd2, pszPageSize);
+		
     TRACE("command: '%s'\n", psCmdP);
 #ifdef HAVE_FORK
     if (*psCmdP == '|')
@@ -505,6 +515,9 @@ static INT PSDRV_StartDocA( PSDRV_PDEVICE *physDev, const DOCINFOA *doc )
     HANDLE hprn = INVALID_HANDLE_VALUE;
     PRINTER_INFO_5A *pi5 = (PRINTER_INFO_5A*)buf;
     DWORD needed;
+    
+    LPCSTR pageSize = NULL;
+    BYTE pSizeBuf[300];
 
     if(physDev->job.id) {
         FIXME("hJob != 0. Now what?\n");
@@ -523,8 +536,35 @@ static INT PSDRV_StartDocA( PSDRV_PDEVICE *physDev, const DOCINFOA *doc )
         if(hprn != INVALID_HANDLE_VALUE)
             ClosePrinter(hprn);
     }
+    
+    /* check if must send page size too */
+    /* if using LPR: as output device, appends the page size */
+    if(!strncmp(output, "LPR", 3) || !strncmp(output, "LPT", 3)) {
+
+        /* gets page size */
+        int sx = MulDiv(physDev->PageSize.cx, 72, physDev->logPixelsX);
+        int sy = MulDiv(physDev->PageSize.cy, 72, physDev->logPixelsY);
+
+        /* scans all supported page sizes to find page name */
+        PAGESIZE *page;
+        LPCSTR paperName = NULL;
+        LIST_FOR_EACH_ENTRY(page, &physDev->pi->ppd->PageSizes, PAGESIZE, entry) {
+            if(page->PaperDimension->x == sx && page->PaperDimension->y == sy) {
+                paperName = page->Name;
+                break;
+            }
+        }
+        if(paperName) {
+            TRACE("PaperName '%s' found for size '%d x %d'\n", paperName, sx, sy);
+            strcpy(pSizeBuf, " -o PageSize=");
+            strcat(pSizeBuf, paperName);
+            pageSize = pSizeBuf;
+        }
+        else
+            FIXME("PaperName not found for size '%d x %d'\n", sx, sy);
+    }
 
-    physDev->job.id = create_job( output );
+    physDev->job.id = create_job( output, pageSize );
     if(!physDev->job.id) {
         WARN("OpenJob failed\n");
 	return 0;
